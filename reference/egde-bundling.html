<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>GeoJSON Edge Bundling</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            background: #f0f0f0;
        }
        
        .line-original {
            fill: none;
            stroke: #999;
            stroke-width: 1;
            opacity: 0.3;
        }
        
        .line-bundled {
            fill: none;
            stroke: #ff6b6b;
            stroke-width: 2;
            opacity: 0.7;
        }
        
        .control-point {
            fill: #4ecdc4;
            stroke: white;
            stroke-width: 1;
        }
        
        .endpoint {
            fill: #2d3436;
            stroke: white;
            stroke-width: 2;
        }
        
        button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <button onclick="toggleBundling()">Toggle Bundling</button>
    <div class="info">
        <div>灰色: 元のGeoJSONライン</div>
        <div>赤: バンドリング後のライン</div>
        <div>青: 制御点（Force Layoutで移動）</div>
    </div>
    
    <div class="note">
実装のポイント
1. GeoJSONからバンドリング用データへの変換
javascriptfunction generateBundlingData(geojson) {
    // 各LineStringの座標を投影変換
    const startProj = projection(coords[0]);
    const endProj = projection(coords[coords.length - 1]);
    
    // 距離に基づいて中間制御点を生成
    const numSegments = Math.max(3, Math.min(10, Math.floor(distance / 50)));
    
    // 線形補間で制御点を配置
    for (let i = 1; i < numSegments; i++) {
        const t = i / numSegments;
        const controlNode = {
            x: startProj[0] + t * (endProj[0] - startProj[1]),
            y: startProj[1] + t * (endProj[1] - startProj[1])
        };
    }
}
2. プロジェクション後の座標で処理
重要な点は、地理座標をプロジェクション変換した後の画面座標でバンドリング処理を行うことです：

GeoJSONの緯度経度 → projection() → 画面座標
Force-directed layoutは画面座標で動作
描画も画面座標で実行

3. D3のcurveBundleを使用
javascriptconst lineGenerator = d3.line()
    .curve(d3.curveBundle.beta(0.85)) // バンドリング強度
    .x(d => d.x)
    .y(d => d.y);
4. 既存のGeoJSONとの併用
元のGeoJSONラインと並べて表示できるので、バンドリング効果を比較できます。
制限事項と注意点

MultiLineStringやPolygon: より複雑なジオメトリの場合は追加の処理が必要
大規模データ: 制御点が多くなるとパフォーマンスに影響
地理的精度: バンドリング後のラインは地理的に正確な経路ではなくなる

この方法により、GeoJSONデータに対してもフライトパスの例と同様のエッジバンドリング効果を適用できます。
    </div>



    <svg width="960" height="600"></svg>
    
    <script>
        // サンプルGeoJSON（複数のLineString）
        const geojsonData = {
            "type": "FeatureCollection",
            "features": [
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": [
                            [-120, 40],
                            [-75, 35]
                        ]
                    }
                },
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": [
                            [-118, 38],
                            [-77, 37]
                        ]
                    }
                },
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": [
                            [-122, 42],
                            [-73, 33]
                        ]
                    }
                },
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": [
                            [-115, 36],
                            [-80, 38]
                        ]
                    }
                },
                {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": [
                            [-119, 41],
                            [-76, 34]
                        ]
                    }
                }
            ]
        };
        
        const svg = d3.select("svg");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        
        // プロジェクション設定
        const projection = d3.geoAlbersUsa()
            .scale(1000)
            .translate([width / 2, height / 2]);
        
        const path = d3.geoPath().projection(projection);
        
        // グループ要素
        const g = {
            original: svg.append("g").attr("id", "original"),
            bundled: svg.append("g").attr("id", "bundled"),
            points: svg.append("g").attr("id", "points")
        };
        
        // 元のGeoJSONラインを描画
        g.original.selectAll("path")
            .data(geojsonData.features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("class", "line-original");
        
        // GeoJSONからエッジバンドリング用のデータを生成
        function generateBundlingData(geojson) {
            const bundle = {
                nodes: [],
                links: [],
                paths: []
            };
            
            const nodeMap = new Map();
            let nodeId = 0;
            
            // 各LineStringを処理
            geojson.features.forEach((feature, featureIndex) => {
                const coords = feature.geometry.coordinates;
                const pathNodes = [];
                
                // 始点と終点を投影
                const startProj = projection(coords[0]);
                const endProj = projection(coords[coords.length - 1]);
                
                // 始点ノード
                const startKey = startProj.join(',');
                if (!nodeMap.has(startKey)) {
                    const startNode = {
                        id: nodeId++,
                        x: startProj[0],
                        y: startProj[1],
                        fx: startProj[0], // 固定
                        fy: startProj[1],
                        type: 'endpoint'
                    };
                    nodeMap.set(startKey, startNode);
                    bundle.nodes.push(startNode);
                }
                pathNodes.push(nodeMap.get(startKey));
                
                // 中間制御点を生成
                const distance = Math.sqrt(
                    Math.pow(endProj[0] - startProj[0], 2) + 
                    Math.pow(endProj[1] - startProj[1], 2)
                );
                const numSegments = Math.max(3, Math.min(10, Math.floor(distance / 50)));
                
                let prevNode = nodeMap.get(startKey);
                
                for (let i = 1; i < numSegments; i++) {
                    const t = i / numSegments;
                    const controlNode = {
                        id: nodeId++,
                        x: startProj[0] + t * (endProj[0] - startProj[0]),
                        y: startProj[1] + t * (endProj[1] - startProj[1]),
                        type: 'control'
                    };
                    bundle.nodes.push(controlNode);
                    pathNodes.push(controlNode);
                    
                    // リンクを追加
                    bundle.links.push({
                        source: prevNode,
                        target: controlNode
                    });
                    prevNode = controlNode;
                }
                
                // 終点ノード
                const endKey = endProj.join(',');
                if (!nodeMap.has(endKey)) {
                    const endNode = {
                        id: nodeId++,
                        x: endProj[0],
                        y: endProj[1],
                        fx: endProj[0], // 固定
                        fy: endProj[1],
                        type: 'endpoint'
                    };
                    nodeMap.set(endKey, endNode);
                    bundle.nodes.push(endNode);
                }
                pathNodes.push(nodeMap.get(endKey));
                
                // 最後のリンク
                bundle.links.push({
                    source: prevNode,
                    target: nodeMap.get(endKey)
                });
                
                bundle.paths.push(pathNodes);
            });
            
            return bundle;
        }
        
        // バンドリングデータを生成
        const bundleData = generateBundlingData(geojsonData);
        
        // D3 curveBundle用のライン生成関数
        const lineGenerator = d3.line()
            .curve(d3.curveBundle.beta(0.85))
            .x(d => d.x)
            .y(d => d.y);
        
        // バンドリングされたパスを描画
        const bundledPaths = g.bundled.selectAll("path")
            .data(bundleData.paths)
            .enter()
            .append("path")
            .attr("class", "line-bundled")
            .attr("d", lineGenerator);
        
        // 制御点を表示（デバッグ用）
        const pointGroups = g.points.selectAll("circle")
            .data(bundleData.nodes)
            .enter()
            .append("circle")
            .attr("r", d => d.type === 'endpoint' ? 6 : 3)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("class", d => d.type === 'endpoint' ? 'endpoint' : 'control-point')
            .style("display", "none");
        
        // Force-directed layoutを適用
        const simulation = d3.forceSimulation(bundleData.nodes)
            .force("charge", d3.forceManyBody()
                .strength(20)
                .distanceMax(100)
            )
            .force("link", d3.forceLink(bundleData.links)
                .strength(0.5)
                .distance(0)
            )
            .alphaDecay(0.02)
            .on("tick", () => {
                bundledPaths.attr("d", lineGenerator);
                pointGroups
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
            });
        
        // バンドリングのオンオフ切り替え
        let showBundling = true;
        window.toggleBundling = function() {
            showBundling = !showBundling;
            g.bundled.style("display", showBundling ? "block" : "none");
            pointGroups.style("display", showBundling ? "block" : "none");
            
            if (showBundling) {
                simulation.alpha(0.3).restart();
            } else {
                simulation.stop();
            }
        };
        
        // 初期状態でシミュレーションを実行
        simulation.alpha(0.3).restart();
    </script>
</body>
</html>