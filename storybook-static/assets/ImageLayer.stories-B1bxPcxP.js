import{B as ae,c as se,M as ie,G as ce}from"./story-helpers-DJRNUMPK.js";import{select as U}from"d3-selection";import*as $ from"d3-geo";import{geoEquirectangular as F}from"d3-geo";import{fromUrl as le}from"geotiff";class J extends ae{constructor(e,t){super(e,t.attr,t.style),this.useAdvancedReprojection=!0,this.useMask=!0,this.src=t.src,this.bounds=t.bounds,this.showBboxMarkers=t.showBboxMarkers??!1,this.useAdvancedReprojection=t.useAdvancedReprojection??!0,this.useMask=t.useMask??!0}setProjection(e){if(this.projection=e,this.isRendered()){if(!this.element||!this.projection)return;const t=U(this.element);t.selectAll("image").remove(),t.selectAll(".bbox-marker").remove(),t.selectAll(".bbox-marker-label").remove(),this.loadImage(this.src).then(o=>{const n=this.projection&&this.isWebMercatorCompatible(this.projection),a=this.projection&&this.isEquirectangularProjection(this.projection);console.log("=== setProjection - 投影法判定結果 ==="),console.log("  isWebMercatorCompatible:",n),console.log("  isEquirectangular:",a),console.log("  useAdvancedReprojection:",this.useAdvancedReprojection),console.log("  Current projection:",this.projection?.toString()),n?(console.log("→ setProjection実行パス: renderSimpleImage (Web Mercator互換)"),this.renderSimpleImage(o)):a?(console.log("→ setProjection実行パス: renderSimpleImage (Equirectangular高速描画)"),this.renderSimpleImage(o)):this.useAdvancedReprojection?(console.log("→ setProjection実行パス: renderAdvancedReprojection (他の投影法)"),this.renderAdvancedReprojection(o)):(console.log("→ setProjection実行パス: renderSimpleImage (フォールバック)"),this.renderSimpleImage(o))}).catch(o=>{console.error("ImageLayer: 更新に失敗しました",o)})}}async render(e){if(!this.projection){console.warn("ImageLayer: 投影法が設定されていません");return}const t=e.append("g").attr("class",`image-layer ${this.attr.className||""}`).attr("id",`layer-${this.id}`);this.visible||t.style("display","none"),this.element=t.node();try{console.log("=== ImageLayer render() 開始 ==="),console.log("Image src:",this.src),console.log("Image bounds:",this.bounds),console.log("useAdvancedReprojection:",this.useAdvancedReprojection),console.log("Projection:",this.projection);const o=await this.loadImage(this.src);console.log("画像読み込み完了:",{width:o.width,height:o.height,src:o.src});const n=this.projection&&this.isWebMercatorCompatible(this.projection),a=this.projection&&this.isEquirectangularProjection(this.projection);console.log("投影法判定結果:"),console.log("  isWebMercatorCompatible:",n),console.log("  isEquirectangular:",a),console.log("  useAdvancedReprojection:",this.useAdvancedReprojection),n?(console.log("→ 実行パス: renderSimpleImage (Web Mercator互換)"),await this.renderSimpleImage(o)):a?(console.log("→ 実行パス: renderSimpleImage (Equirectangular高速描画)"),await this.renderSimpleImage(o)):this.useAdvancedReprojection?(console.log("→ 実行パス: renderAdvancedReprojection (他の投影法)"),await this.renderAdvancedReprojection(o)):(console.log("→ 実行パス: renderSimpleImage (フォールバック)"),await this.renderSimpleImage(o)),console.log("=== ImageLayer render() 完了 ===")}catch(o){console.error("ImageLayer: 画像の描画に失敗しました",o)}}loadImage(e){return new Promise((t,o)=>{const n=new Image;n.crossOrigin="anonymous",n.onload=()=>t(n),n.onerror=()=>o(new Error(`画像の読み込みに失敗しました: ${e}`)),n.src=e})}isEquirectangularProjection(e){const t=e.toString?e.toString():"";return t.includes("equirectangular")||t.includes("Equirectangular")}isWebMercatorCompatible(e){const t=e.toString?e.toString():"";if(console.log("=== Web Mercator compatibility check ==="),console.log("Projection toString:",t),t.includes("mercator")||t.includes("Mercator"))return console.log("→ Detected as Mercator projection by string match"),!0;if(typeof e.scale=="function"&&typeof e.translate=="function"&&typeof e.center=="function"){const o=e.scale(),n=e.translate();if(console.log("Projection details for compatibility check:",{scale:o,translate:n}),!t.includes("equirectangular")&&!t.includes("Equirectangular")&&!t.includes("naturalEarth")&&!t.includes("orthographic"))return console.log("→ Detected as Mercator-compatible by feature analysis"),!0}return console.log("→ Not Web Mercator compatible"),!1}saveProjectionState(e){return{scale:e.scale(),translate:e.translate(),center:e.center()}}restoreProjectionState(e,t){e.scale(t.scale),e.translate(t.translate),e.center(t.center)}createImageProjection(e){const t=e.toString?e.toString():"";if(console.log("=== Creating image-specific projection ==="),console.log("Base projection:",t),this.isEquirectangularProjection(e)){const[o,n,a,s]=this.bounds,r=F().center([(o+a)/2,(n+s)/2]).scale(1).translate([0,0]);return console.log("→ Created optimized Equirectangular projection for image"),console.log("→ Image center:",[(o+a)/2,(n+s)/2]),r}return console.log("→ Using base projection with state management"),e}renderSimpleImage(e){if(!this.element||!this.projection)return;const[t,o,n,a]=this.bounds,s=this.saveProjectionState(this.projection);console.log("=== renderSimpleImage with projection state management ==="),console.log("Original projection state:",s);let r=this.projection,u=!1;if(this.isEquirectangularProjection(this.projection)){r=this.createImageProjection(this.projection),u=!0;const M=n-t,A=a-o,L=Math.min(s.translate[0]*2/M,s.translate[1]*2/A)*.8;r.scale(L).translate(s.translate).center([(t+n)/2,(o+a)/2]),console.log("→ Using optimized image projection"),console.log("→ Image projection scale:",L),console.log("→ Image projection center:",[(t+n)/2,(o+a)/2])}else console.log("→ Using original projection as-is");const y=r([t,a]),g=r([n,a]),x=r([t,o]),w=r([n,o]);console.log("=== ImageLayer bbox projection ==="),console.log("Original bbox coordinates:"),console.log("  West (left):",t),console.log("  South (bottom):",o),console.log("  East (right):",n),console.log("  North (top):",a),console.log("Original bbox:",{west:t,south:o,east:n,north:a}),console.log("Image size:",{width:e.width,height:e.height}),console.log(""),console.log("Working projection details:"),r&&typeof r.scale=="function"&&(console.log("  Working projection scale:",r.scale()),console.log("  Working projection translate:",r.translate()),console.log("  Working projection center:",r.center())),console.log(""),console.log("Input coordinates for projection:"),console.log("  Top-left input: [",t,",",a,"]"),console.log("  Top-right input: [",n,",",a,"]"),console.log("  Bottom-left input: [",t,",",o,"]"),console.log("  Bottom-right input: [",n,",",o,"]"),console.log(""),console.log("Projected coordinates (output):"),console.log("  Top-left (west, north):",y),console.log("  Top-right (east, north):",g),console.log("  Bottom-left (west, south):",x),console.log("  Bottom-right (east, south):",w),console.log(""),console.log("Projection details:"),console.log("  Projection function:",this.projection?.toString()),this.projection&&typeof this.projection.scale=="function"&&console.log("  Scale:",this.projection.scale()),this.projection&&typeof this.projection.translate=="function"&&console.log("  Translate:",this.projection.translate());let c=y,j=g,d=x,l=w;if(u&&!this.isEquirectangularProjection(this.projection)&&(console.log("→ Converting coordinates to original projection space"),r.invert&&y&&w)){const M=r.invert(y),A=r.invert(w);M&&A&&(c=this.projection(M),l=this.projection(A),console.log("→ Converted coordinates:",{topLeft:c,bottomRight:l}))}if(!c||!l){console.warn("ImageLayer: 境界が投影範囲外です");return}const f=c[0],p=c[1],i=Math.abs(l[0]-c[0]),m=Math.abs(l[1]-c[1]);console.log("Projected position (top-left):",{x:f,y:p}),console.log("Projected size:",{width:i,height:m}),console.log("Original image size:",{width:e.width,height:e.height}),console.log("Size scaling factor:",{x:i/e.width,y:m/e.height});const v=n-t,R=a-o;console.log("Geographic size:",{width:v,height:R}),console.log("Geographic aspect ratio:",v/R),console.log("Projected aspect ratio:",i/m),console.log("Image aspect ratio:",e.width/e.height),console.log("====================================="),console.log("=== DOM要素作成開始 ==="),console.log("元画像URL:",e.src);const I=U(this.element);this.imageElement=I.append("image").attr("x",f).attr("y",p).attr("width",i).attr("height",m).attr("href",e.src).attr("preserveAspectRatio","none"),console.log("image要素作成直後のhref:",this.imageElement.attr("href")),console.log("image要素作成直後の属性:",{x:this.imageElement.attr("x"),y:this.imageElement.attr("y"),width:this.imageElement.attr("width"),height:this.imageElement.attr("height")}),this.showBboxMarkers&&this.addBboxMarkers(I,[c,j,d,l]),console.log("applyAllStylesToElement実行前のhref:",this.imageElement.attr("href")),this.imageElement&&(this.applyAllStylesToElement(this.imageElement,this.getLayerGroup()),console.log("applyAllStylesToElement実行後のhref:",this.imageElement.attr("href"))),this.isEquirectangularProjection(this.projection)||(this.restoreProjectionState(this.projection,s),console.log("→ Restored original projection state")),console.log("=== DOM要素作成完了 ===")}async renderTransformedImage(e){if(!this.element||!this.projection)return;if(e.width>1e3||e.height>1e3)throw new Error("ImageLayer: 投影変換を行う場合、画像サイズは1000×1000ピクセル以下にしてください");const t=await this.transformRasterImage(e),o=await this.loadImage(t),n=U(this.element);this.imageElement=n.append("image").attr("x",0).attr("y",0).attr("width",o.width).attr("height",o.height).attr("href",t).attr("preserveAspectRatio","none"),this.imageElement&&this.applyAllStylesToElement(this.imageElement,this.getLayerGroup())}async transformRasterImage(e){if(!this.projection)throw new Error("投影法が設定されていません");const[t,o,n,a]=this.bounds,s=document.createElement("canvas"),r=s.getContext("2d");if(!r)throw new Error("Canvas contextの取得に失敗しました");s.width=e.width,s.height=e.height,r.drawImage(e,0,0);const u=r.getImageData(0,0,e.width,e.height),g=[[t,a],[n,a],[n,o],[t,o],[(t+n)/2,a],[(t+n)/2,o],[t,(a+o)/2],[n,(a+o)/2]].map(i=>this.projection(i)).filter(i=>i!==null);if(g.length===0)throw new Error("ImageLayer: 画像が投影範囲外です");const x=Math.floor(Math.min(...g.map(i=>i[0]))),w=Math.ceil(Math.max(...g.map(i=>i[0]))),c=Math.floor(Math.min(...g.map(i=>i[1]))),j=Math.ceil(Math.max(...g.map(i=>i[1]))),d=document.createElement("canvas"),l=d.getContext("2d");if(!l)throw new Error("Canvas contextの取得に失敗しました");d.width=w-x,d.height=j-c;const f=l.createImageData(d.width,d.height),p=f.data;for(let i=0;i<d.height;i++)for(let m=0;m<d.width;m++){const v=m+x,R=i+c,I=this.approximateInverseProjection(v,R,t,o,n,a);if(I){const[M,A]=I,L=Math.round((M-t)/(n-t)*(e.width-1)),h=Math.round((a-A)/(a-o)*(e.height-1));if(L>=0&&L<e.width&&h>=0&&h<e.height){const b=(h*e.width+L)*4,S=(i*d.width+m)*4;p[S]=u.data[b],p[S+1]=u.data[b+1],p[S+2]=u.data[b+2],p[S+3]=u.data[b+3]}}}return l.putImageData(f,0,0),d.toDataURL()}approximateInverseProjection(e,t,o,n,a,s){if(!this.projection)return null;let r=o,u=a,y=n,g=s;const x=.5,w=20;for(let c=0;c<w;c++){const j=(r+u)/2,d=(y+g)/2,l=this.projection([j,d]);if(!l)return null;const[f,p]=l;if(Math.abs(f-e)<x&&Math.abs(p-t)<x)return[j,d];f<e?r=j:u=j,p<t?g=d:y=d}return[(r+u)/2,(y+g)/2]}addBboxMarkers(e,t){const o=t.filter(s=>s!==null),n=["#e74c3c","#3498db","#2ecc71","#f39c12"],a=["NW","NE","SW","SE"];o.forEach((s,r)=>{const u=e.append("g").attr("class","bbox-marker").attr("transform",`translate(${s[0]}, ${s[1]})`);u.append("circle").attr("r",6).attr("fill","white").attr("stroke",n[r]||"#9b59b6").attr("stroke-width",2),u.append("circle").attr("r",4).attr("fill",n[r]||"#9b59b6"),u.append("text").attr("x",10).attr("y",4).attr("font-size","11px").attr("font-family","Arial, sans-serif").attr("fill",n[r]||"#9b59b6").attr("font-weight","bold").attr("class","bbox-marker-label").text(a[r]||`${r+1}`)})}async renderAdvancedReprojection(e){if(!(!this.element||!this.projection))try{const t=await this.advancedTransformRasterImage(e),o=await this.loadImage(t.dataUrl),n=U(this.element);if(this.imageElement=n.append("image").attr("x",t.x).attr("y",t.y).attr("width",t.width).attr("height",t.height).attr("href",t.dataUrl).attr("preserveAspectRatio","none"),this.imageElement&&this.applyAllStylesToElement(this.imageElement,this.getLayerGroup()),this.showBboxMarkers){const[a,s,r,u]=this.bounds,y=this.projection([a,u]),g=this.projection([r,u]),x=this.projection([a,s]),w=this.projection([r,s]);this.addBboxMarkers(n,[y,g,x,w])}}catch(t){console.warn("高度な再投影に失敗しました。単純な描画にフォールバックします。",t),this.renderSimpleImage(e)}}async advancedTransformRasterImage(e){if(!this.projection)throw new Error("投影法が設定されていません");const[t,o,n,a]=this.bounds,s=document.createElement("canvas"),r=s.getContext("2d");if(!r)throw new Error("Canvas contextの取得に失敗しました");s.width=e.width,s.height=e.height,r.drawImage(e,0,0);const u=r.getImageData(0,0,e.width,e.height);F().scale(1).translate([0,0]);const y=this.calculateOutputBounds();if(!y)throw new Error("出力範囲の計算に失敗しました");const{minX:g,minY:x,width:w,height:c}=y,j=document.createElement("canvas"),d=j.getContext("2d");if(!d)throw new Error("Canvas contextの取得に失敗しました");j.width=w,j.height=c;const l=document.createElement("canvas"),f=l.getContext("2d");if(!f)throw new Error("Mask contextの取得に失敗しました");l.width=w,l.height=c,f.fillStyle="#fff";const p=h=>{const b=this.projection(h);return b?[b[0]-g,b[1]-x]:null};f.beginPath();const i=[],m=50;console.log("=== Advanced reprojection mask creation ==="),console.log("Image bounds:",{west:t,south:o,east:n,north:a});for(let h=0;h<=m;h++){const b=t+(n-t)*h/m,S=p([b,a]);S&&i.push(S)}for(let h=0;h<=m;h++){const b=a-(a-o)*h/m,S=p([n,b]);S&&i.push(S)}for(let h=0;h<=m;h++){const b=n-(n-t)*h/m,S=p([b,o]);S&&i.push(S)}for(let h=0;h<=m;h++){const b=o+(a-o)*h/m,S=p([t,b]);S&&i.push(S)}if(console.log("Generated boundary points:",i.length),i.length>0){f.moveTo(i[0][0],i[0][1]);for(let h=1;h<i.length;h++)f.lineTo(i[h][0],i[h][1]);f.closePath(),f.fill()}const v=f.getImageData(0,0,w,c),R=d.createImageData(w,c);console.log("=== Pixel transformation started ==="),console.log("Output canvas size:",{width:w,height:c}),console.log("Source image size:",{width:e.width,height:e.height});let I=0,M=0;const A=w*c,L=Math.floor(A/10);for(let h=0;h<c;h++)for(let b=0;b<w;b++){if(I++,I%L===0){const z=Math.floor(I/A*100);console.log(`Transformation progress: ${z}% (${I}/${A})`)}if(this.useMask){const z=(h*w+b)*4;if(v.data[z+3]===0)continue}const S=b+g+.5,G=h+x+.5,W=this.inverseProjectWithFallback(S,G,t,o,n,a);if(W){const z=(W[0]-t)/(n-t)*(e.width-1),_=(a-W[1])/(a-o)*(e.height-1),E=this.bilinearInterpolate(u,z,_),C=(h*w+b)*4;R.data[C]=E[0],R.data[C+1]=E[1],R.data[C+2]=E[2],R.data[C+3]=E[3],M++}}return console.log("=== Pixel transformation completed ==="),console.log("Successful transforms:",M,"/",A),console.log("Success rate:",Math.round(M/A*100),"%"),d.putImageData(R,0,0),{dataUrl:j.toDataURL(),x:g,y:x,width:w,height:c}}calculateOutputBounds(){if(!this.projection)return null;const[e,t,o,n]=this.bounds,a=[],s=20;for(let j=0;j<=s;j++){const d=j/s;a.push([e+(o-e)*d,n],[e+(o-e)*d,t],[e,t+(n-t)*d],[o,t+(n-t)*d])}const r=a.map(j=>this.projection(j)).filter(j=>j!==null);if(r.length===0)return null;const u=r.map(j=>j[0]),y=r.map(j=>j[1]),g=Math.floor(Math.min(...u)),x=Math.ceil(Math.max(...u)),w=Math.floor(Math.min(...y)),c=Math.ceil(Math.max(...y));return{minX:g,minY:w,width:x-g,height:c-w}}inverseProjectWithFallback(e,t,o,n,a,s){if(!this.projection)return null;if(typeof this.projection.invert=="function")try{const r=this.projection.invert([e,t]);if(r&&r[0]>=o&&r[0]<=a&&r[1]>=n&&r[1]<=s)return r}catch{}return this.approximateInverseProjection(e,t,o,n,a,s)}bilinearInterpolate(e,t,o){const n=Math.floor(t),a=Math.min(n+1,e.width-1),s=Math.floor(o),r=Math.min(s+1,e.height-1),u=t-n,y=o-s,g=(l,f)=>{const p=(f*e.width+l)*4;return[e.data[p],e.data[p+1],e.data[p+2],e.data[p+3]]},x=g(n,s),w=g(a,s),c=g(n,r),j=g(a,r),d=[0,0,0,0];for(let l=0;l<4;l++){const f=x[l]*(1-u)+w[l]*u,p=c[l]*(1-u)+j[l]*u;d[l]=Math.round(f*(1-y)+p*y)}return d}}async function he(k,e={}){const{resampleMethod:t="nearest",imageIndex:o=0,samples:n=[0,1,2],pool:a,sizeLimit:s={maxWidth:512,maxHeight:512,onExceed:"resample"},outputWidth:r,outputHeight:u,bbox:y}=e,g=s.maxWidth??512,x=s.maxHeight??512,w=s.onExceed??"resample";try{const c=await le(k),j=await c.getImageCount();if(o>=j)throw new Error(`画像インデックス ${o} は範囲外です。利用可能なインデックス: 0-${j-1}`);const d=await c.getImage(o),l=d.getWidth(),f=d.getHeight();let p,i;try{p=d.getBoundingBox(),i=[p[0],p[1],p[2],p[3]]}catch{p=(await c.getImage(0)).getBoundingBox(),i=[p[0],p[1],p[2],p[3]]}let m=r??l,v=u??f,R=!1;if(m>g||v>x){if(w==="error")throw new Error(`画像サイズ（${l}x${f}）が制限（${g}x${x}）を超えています`);const E=l/f;m/v>E?(v=x,m=Math.floor(v*E)):(m=g,v=Math.floor(m/E)),R=!0}(r||u)&&(R=!0);const I={samples:n,pool:a,interleave:!0};if(y){const[E,C,O,T]=y,[P,B,q,D]=p,K=Math.floor((E-P)/(q-P)*l),Q=Math.ceil((O-P)/(q-P)*l),Z=Math.floor((D-T)/(D-B)*f),ee=Math.ceil((D-C)/(D-B)*f);I.window=[Math.max(0,K),Math.max(0,Z),Math.min(l,Q),Math.min(f,ee)],m=I.window[2]-I.window[0],v=I.window[3]-I.window[1];const te=P+I.window[0]/l*(q-P),oe=P+I.window[2]/l*(q-P),re=D-I.window[1]/f*(D-B),ne=D-I.window[3]/f*(D-B);i=[te,ne,oe,re]}if(R||m>g||v>x){const E=m/v;(m>g||v>x)&&(m/v>E?(v=x,m=Math.floor(v*E)):(m=g,v=Math.floor(m/E)),R=!0),I.width=m,I.height=v,I.resampleMethod=t}let M,A,L;try{M=await d.readRGB(I),A=M.width,L=M.height}catch{if(M=await d.readRasters(I),A=M.width,L=M.height,Array.isArray(M)){const C=Math.min(3,M.length),O=A*L,T=new Uint8Array(O*3);for(let P=0;P<O;P++){for(let B=0;B<C;B++)T[P*3+B]=M[B][P]||0;for(let B=C;B<3;B++)T[P*3+B]=0}M=T}}const h=document.createElement("canvas");h.width=A,h.height=L;const b=h.getContext("2d");if(!b)throw new Error("Canvas contextの取得に失敗しました");const S=b.createImageData(A,L),G=S.data,W=M,z=A*L;for(let E=0;E<z;E++){const C=E*4,O=E*3;if(O+2<W.length)G[C]=W[O]||0,G[C+1]=W[O+1]||0,G[C+2]=W[O+2]||0;else{const T=W[E]||0;G[C]=T,G[C+1]=T,G[C+2]=T}G[C+3]=255}return b.putImageData(S,0,0),{dataUri:h.toDataURL("image/png"),bounds:i,width:A,height:L,originalWidth:l,originalHeight:f,wasResampled:R}}catch(c){throw new Error(`COGの読み込みに失敗しました: ${c instanceof Error?c.message:String(c)}`)}}const we={title:"Layers/ImageLayer",tags:["autodocs"],parameters:{docs:{description:{component:"画像を地図上に表示するレイヤー。静的画像とCOG（Cloud Optimized GeoTIFF）の両方をサポートします。"}}},argTypes:{imageSource:{control:{type:"radio"},options:["static","cog"],description:"画像ソースタイプ",defaultValue:"static"},showBboxMarkers:{control:{type:"boolean"},description:"バウンディングボックスマーカーを表示",defaultValue:!1},useAdvancedReprojection:{control:{type:"boolean"},description:"高度な再投影を使用",defaultValue:!0},useMask:{control:{type:"boolean"},description:"マスク処理を使用",defaultValue:!0},opacity:{control:{type:"range",min:0,max:1,step:.1},description:"透明度",defaultValue:.8},projection:{control:{type:"select"},options:["naturalEarth1","mercator","equirectangular","orthographic"],description:"投影法",defaultValue:"naturalEarth1"},cogImageIndex:{control:{type:"range",min:0,max:6,step:1},description:"COG画像インデックス（オーバービューレベル）",defaultValue:0},cogSizeLimit:{control:{type:"select"},options:[256,512,1024,2048],description:"COGサイズ制限",defaultValue:512},showGraticule:{control:{type:"boolean"},description:"経緯線を表示",defaultValue:!0}}};function ge(k,e,t){let o;switch(k){case"mercator":o=$.geoMercator();break;case"equirectangular":o=$.geoEquirectangular();break;case"orthographic":o=$.geoOrthographic().rotate([-10,-20]);break;case"naturalEarth1":default:o=$.geoNaturalEarth1();break}return o.scale(120).translate([e/2,t/2])}const de="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==";function X(k){const e=se(),t=800,o=500,n=ge(k.projection,t,o),a=new ie({container:"#map",width:t,height:o,projection:n,backgroundColor:"#f0f8ff"});if(k.showGraticule){const s=new ce({step:[30,30],attr:{fill:"none",stroke:"#ddd",strokeWidth:.5,strokeDasharray:"2,2",opacity:.7}});a.addLayer("graticule",s)}if(k.imageSource==="cog"){const s=document.createElement("div");s.innerHTML="<p>COG読み込み中...</p>",s.style.position="absolute",s.style.top="10px",s.style.left="10px",s.style.background="rgba(255,255,255,0.9)",s.style.padding="10px",s.style.borderRadius="4px",e.appendChild(s),he("https://storage.googleapis.com/g3-open-resource/d3-thematika/cog/NE1_HR_SR_OB_DRv6_COG.tif",{imageIndex:k.cogImageIndex,bbox:[-82,-56,-34,13],sizeLimit:{maxWidth:k.cogSizeLimit,maxHeight:k.cogSizeLimit,onExceed:"resample"},resampleMethod:"bilinear"}).then(r=>{s.innerHTML=`
          <p><strong>COG読み込み完了</strong></p>
          <p>サイズ: ${r.width} × ${r.height}</p>
          <p>元サイズ: ${r.originalWidth} × ${r.originalHeight}</p>
          <p>リサンプリング: ${r.wasResampled?"あり":"なし"}</p>
        `;const u=new J("cog-image",{src:r.dataUri,bounds:r.bounds,showBboxMarkers:k.showBboxMarkers,useAdvancedReprojection:k.useAdvancedReprojection,useMask:k.useMask,attr:{opacity:k.opacity}}),[y,g,x,w]=r.bounds,c={type:"LineString",coordinates:[[y,g],[x,w]]};n.fitExtent([[50,50],[t-50,o-50]],c),a.addLayer("image",u)}).catch(r=>{console.error("Image loading error:",r),s.innerHTML=`<p style="color: red;">画像読み込みエラー: ${r instanceof Error?r.message:String(r)}</p>`})}else{const s=new J("static-image",{src:de,bounds:[130,30,145,45],showBboxMarkers:k.showBboxMarkers,useAdvancedReprojection:k.useAdvancedReprojection,useMask:k.useMask,attr:{opacity:k.opacity}});a.addLayer("image",s);const r=document.createElement("div");r.innerHTML=`
        <p><strong>静的画像デモ</strong></p>
        <p>境界: 日本周辺 [130°-145°E, 30°-45°N]</p>
        <p>※実際の使用時は有効な画像URLを指定してください</p>
      `,r.style.position="absolute",r.style.top="10px",r.style.left="10px",r.style.background="rgba(255,255,255,0.9)",r.style.padding="10px",r.style.borderRadius="4px",r.style.fontSize="12px",e.appendChild(r)}return e}const H={args:{imageSource:"static",showBboxMarkers:!1,useAdvancedReprojection:!0,useMask:!0,opacity:.8,projection:"naturalEarth1",cogImageIndex:0,cogSizeLimit:512,showGraticule:!0},render:X},N={args:{imageSource:"cog",showBboxMarkers:!0,useAdvancedReprojection:!0,useMask:!0,opacity:.9,projection:"naturalEarth1",cogImageIndex:0,cogSizeLimit:512,showGraticule:!0},render:X},Y={args:{imageSource:"cog",showBboxMarkers:!1,useAdvancedReprojection:!0,useMask:!0,opacity:1,projection:"equirectangular",cogImageIndex:0,cogSizeLimit:1024,showGraticule:!1},render:X},V={args:{imageSource:"cog",showBboxMarkers:!0,useAdvancedReprojection:!1,useMask:!1,opacity:.7,projection:"mercator",cogImageIndex:3,cogSizeLimit:256,showGraticule:!0},render:X};H.parameters={...H.parameters,docs:{...H.parameters?.docs,source:{originalSource:`{
  args: {
    imageSource: 'static',
    showBboxMarkers: false,
    useAdvancedReprojection: true,
    useMask: true,
    opacity: 0.8,
    projection: 'naturalEarth1',
    cogImageIndex: 0,
    cogSizeLimit: 512,
    showGraticule: true
  },
  render: createImageStory
}`,...H.parameters?.docs?.source}}};N.parameters={...N.parameters,docs:{...N.parameters?.docs,source:{originalSource:`{
  args: {
    imageSource: 'cog',
    showBboxMarkers: true,
    useAdvancedReprojection: true,
    useMask: true,
    opacity: 0.9,
    projection: 'naturalEarth1',
    cogImageIndex: 0,
    cogSizeLimit: 512,
    showGraticule: true
  },
  render: createImageStory
}`,...N.parameters?.docs?.source}}};Y.parameters={...Y.parameters,docs:{...Y.parameters?.docs,source:{originalSource:`{
  args: {
    imageSource: 'cog',
    showBboxMarkers: false,
    useAdvancedReprojection: true,
    useMask: true,
    opacity: 1.0,
    projection: 'equirectangular',
    cogImageIndex: 0,
    cogSizeLimit: 1024,
    showGraticule: false
  },
  render: createImageStory
}`,...Y.parameters?.docs?.source}}};V.parameters={...V.parameters,docs:{...V.parameters?.docs,source:{originalSource:`{
  args: {
    imageSource: 'cog',
    showBboxMarkers: true,
    useAdvancedReprojection: false,
    useMask: false,
    opacity: 0.7,
    projection: 'mercator',
    cogImageIndex: 3,
    cogSizeLimit: 256,
    showGraticule: true
  },
  render: createImageStory
}`,...V.parameters?.docs?.source}}};const je=["StaticImage","COGImage","COGHighResolution","COGOverview"];export{Y as COGHighResolution,N as COGImage,V as COGOverview,H as StaticImage,je as __namedExportsOrder,we as default};
